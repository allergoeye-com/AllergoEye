//=================================================
//
//=================================================
new MainMenu::OnRecalculateAll(...) = <|
	new list = Odml2Exec("select im.Path from DBPicture as im", << >>);
	new dir = AllergoEyeIni->ReadStr("DIR", "DATA");
	if (dir->GetLastByte() != FD)
		dir @= SFD;
	new prg = instance GProgressWnd(TRUE, "Calculate", self);
	for (new i = 0; i < list->Len(); i += 30)
	{
		prg->SetProgress(i * 100 / list->Len());
		prg->CheckCancel();
		Pluk->FlushIdle();
		new f = instance File(JustDirName(ExeName) @ "ae_exchange.tmp");
		f->Open("wb");
		for (new j = i; j < Min(i + 30, list->Len()); ++j)
			f->Putv(dir @ list[j]);
		f->Close();
		Pluk->FlushIdle();
		Pluk->Exec(Printf("%snn-test.exe %s %s /recalc /l%snn-test.log", JustDirName(ExeName), "ae", f.FileName, JustDirName(ExeName)), TRUE, FALSE);
		Pluk->FlushIdle();
	}
|>;
//=================================================
//
//=================================================
new DBTest::GetTestOrder(void) = <|
	new p = .Path->Tokenize("/");
	p = p->Last();
	p = p->Tokenize("_");
	switch (p[1])
	{
	case "Eingangsuntersuchung" :
	case "eingangsuntersuchung" :
	case "Entrance examination" :
	case "entrance examination" :
	case "start test" :
	case "Start test" :
		return -1;
	case "Kontrolllösung" : 
	case "kontrolllösung" : 
	case "Control solution" :
	case "control solution" :
		return 0;
	case "1-100 000" :
	case "1-100000" :
		return 1;
	case "1-10 000" :
	case "1-10000" :
		return 2;
	case "1-1 000" :
	case "1-1000" :
		return 3;
	case "1-100" :
		return 4;
	case "1-10" :
		return 5;
	case "Stocklösung" :
	case "stocklösung" :
	case "Stock solution" :
	case "stock solution" :
		return 6;
	}
|>;
//=================================================
//
//=================================================
new DBTest::CalculateScore(void) = <|
	onerror {
		return;
	};
	new score = 0.0;
	for (new i = 0; i < .Pictures->Len(); ++i)
	{
		switch(.Pictures[i].Eye)
		{
		case "left":
			score += .Pictures[i].ScoreL;
			break;
		case "right":
			score += .Pictures[i].ScoreR;
			break;
		case "both":
			score += (.Pictures[i].ScoreL + .Pictures[i].ScoreR) / 2.0;
			break;
		}
	}
	score /= .Pictures->Len();
	.AEScore = score;
	return score;
|>;
//=================================================
//
//=================================================
new DBDate::GetAEScore(void) = <|
	onerror {
		return;
	};
	.Tests->QSort(<|param key, elem; return key->GetTestOrder() <> elem->GetTestOrder(); |>);
	
	new score = 0.0;
	new offset = 0.0;
	new count = 0;
	for (new i = 0; i < .Tests->Len(); ++i)
	{
		if (.Tests[i].AEScore < -1000.0)
			continue; 
		new r = .Tests[i]->GetTestOrder();
		if (r == 0 || r == -1)
			offset = .Tests[i].AEScore;
		else
		{
			new v = Max(0.0, .Tests[i].AEScore - offset) * 4.0;
			if (v > 0)
				score += (6 - r) + v;
			++count;
		}
	}
	if (count > 0)
		score /= count;
	return score;
|>;
//=================================================
//
//=================================================
new DBDate::GetOpScore(void) = <|
	onerror {
		return;
	};
	.Tests->QSort(<|param key, elem; return key->GetTestOrder() <> elem->GetTestOrder(); |>);
	
	new score = 0.0;
	new offset = 0.0;
	new count = 0;
	for (new i = 0; i < .Tests->Len(); ++i)
	{
		if (.Tests[i].OpScore < -1000.0)
			continue; 
		new r = .Tests[i]->GetTestOrder();
		if (r == 0 || r == -1)
			offset = .Tests[i].OpScore;
		else
		{
			new v = Max(0.0, .Tests[i].OpScore - offset);
			if (v > 0)
				score += (6 - r) + v;
			++count;
		}
	}
	if (count > 0)
		score /= count;
	return score;
|>;
//=================================================
//
//=================================================
new DBDate::GetOpRScore(void) = <|
	onerror {
		return;
	};
	.Tests->QSort(<|param key, elem; return key->GetTestOrder() <> elem->GetTestOrder(); |>);
	
	new score = 0.0;
	new offset = 0.0;
	new count = 0;
	for (new i = 0; i < .Tests->Len(); ++i)
	{
		if (.Tests[i].OpScore < -1000.0)
			continue; 
		new r = .Tests[i]->GetTestOrder();
		if (r == 0 || r == -1)
			offset = .Tests[i].OpScoreV[3];
		else
		{
			new v = Max(0.0, .Tests[i].OpScoreV[3] - offset);
			if (v > 0)
				score += (6 - r) + v;
			++count;
		}
	}
	if (count > 0)
		score /= count;
	return score;
|>;
//=================================================
//
//=================================================
new DBDate::GetOpSynScore(void) = <|
	onerror {
		return;
	};
	.Tests->QSort(<|param key, elem; return key->GetTestOrder() <> elem->GetTestOrder(); |>);
	
	new score = 0.0;
	new offset = 0.0;
	new count = 0;
	for (new i = 0; i < .Tests->Len(); ++i)
	{
		if (.Tests[i].OpScore < -1000.0 || .Tests[i].AEScore < -1000.0)
			continue; 
		new r = .Tests[i]->GetTestOrder();

		new v = .Tests[i].OpScoreV[0] + .Tests[i].OpScoreV[1] + .Tests[i].OpScoreV[2] + .Tests[i].AEScore * 2.0;
		
		if (r == 0 || r == -1)
			offset = v;
		else
		{
			new v = Max(0.0, v - offset);
			if (v > 0)
				score += (6 - r) + v;
			++count;
		}
	}
	if (count > 0)
		score /= count;
	return score;
|>;
//=================================================
//
//=================================================
new MainMenu::OnImportOpScore(...) = <|
	new f = instance File(instance GOpenDialog("csv", "", "*.csv|*.csv", self)->Open());
	f->Open("rb");
	new op = f->ReadCSV();

	for (new i = 0; i < op->Len(); ++i)
	{
		new rec = op[i];
		new id = int(rec[2]);
		new p = Odml2Exec("select p from DBPatient as p where p.PatientID = ?", << id >>);
		if (p->Len() == 1)
		{
			if (p[0].Date->Len() > 1)
				p[0].Date->QSort(<|param key, elem; return key.Date <> elem.Date; |>);
			for (new d = 0; d < p[0].Date->Len(); ++d)
			{
				p[0].Date[d].Tests->QSort(<|param key, elem; return key->GetTestOrder() <> elem->GetTestOrder(); |>);;
			}
			new rep = int(rec[1]) - 1;
			for (new j = 3; j < rec->Len(); ++j)
				if (rec[j] != EMPTY && rec[j] != "")
					rec[j] = float(rec[j]);
			if (rep < p[0].Date->Len())
			{
				for (new k = 0; k < p[0].Date[rep].Tests->Len(); ++k)
				{
					if (p[0].Date[rep].Tests[k].Pictures->Len() == 0)
					{
						stop;
						continue;
					}
					p[0].Date[rep].Tests[k]->CalculateScore();
					new index = p[0].Date[rep].Tests[k]->GetTestOrder();
					switch (index)
					{
					case -1:
					case 0 :
						p[0].Date[rep].Tests[k].OpScore = rec[7];
						p[0].Date[rep].Tests[k].OpScoreV = rec->Mid(3, 4);
						break;
					default:
						index -= 2;
						p[0].Date[rep].Tests[k].OpScore = rec[7 + 5 * index];
						p[0].Date[rep].Tests[k].OpScoreV = rec->Mid(3 + 5 * index, 4);
						break;
					}
					p[0].Date[rep].Tests[k]->Save();
				}
				trace Printf("OpScore = %g, AEScore = %g\r\n", p[0].Date[rep]->GetOpScore(), p[0].Date[rep]->GetAEScore()); 
			} 
		}
	}
	trace "OK", CR;
|>;
//===============================================
//===============================================
new MainMenu::OnExportStat(...) = <|


	new list = Odml2Exec("select p from DBPatient as p", << >>);
	trace "Op1, Op2, AE1, AE2, OpR1, OpR2, Syn1, Syn2\r\n";

	for (new i = 0; i < list->Len(); ++i)
	{
		if (list[i].Date->Len() > 1)
		{
			list[i].Date->QSort(<|param key, elem; return key.Date <> elem.Date; |>);
			for (new d = 0; d < list[i].Date->Len(); ++d)
				list[i].Date[d].Tests->QSort(<|param key, elem; return key->GetTestOrder() <> elem->GetTestOrder(); |>);
			trace Printf("%d %g, %g, %g, %g, %g, %g, %g, %g\r\n", list[i].PatientID,
										list[i].Date[0]->GetOpScore(), list[i].Date[1]->GetOpScore(),
										list[i].Date[0]->GetAEScore() * 2, list[i].Date[1]->GetAEScore() * 2,
										list[i].Date[0]->GetOpRScore(), list[i].Date[1]->GetOpRScore(),
										list[i].Date[0]->GetOpSynScore(), list[i].Date[1]->GetOpSynScore()); 
		}
	}
|>;
//===============================================
//===============================================
new MainMenu::OnExportStat_Split(...) = <|


	new list = Odml2Exec("select p from DBPatient as p", << >>);

	trace "Start Therapy (Op.Score), 3 Months Therapy (Op.Score)\r\n";
	new S1 = << >>;
	new S2 = << >>;
	new Delta = << >>;
	for (new i = 0; i < list->Len(); ++i)
	{
		if (list[i].PatientID == 9594 || list[i].PatientID == 3434 || list[i].PatientID == 8875)
			continue;
		if (list[i].Date->Len() > 1)
		{
			list[i].Date->QSort(<|param key, elem; return key.Date <> elem.Date; |>);
			for (new d = 0; d < list[i].Date->Len(); ++d)
				list[i].Date[d].Tests->QSort(<|param key, elem; return key->GetTestOrder() <> elem->GetTestOrder(); |>);
			trace Printf("%g, %g\r\n", //list[i].PatientID,
										list[i].Date[0]->GetOpScore(), list[i].Date[1]->GetOpScore());
			S1 ,= list[i].Date[0]->GetOpScore();
			S2 ,= list[i].Date[1]->GetOpScore();
			Delta ,= list[i].Date[0]->GetOpScore() - list[i].Date[1]->GetOpScore();
		}
	}
	new s1 = instance Stat(S1);
	new s2 = instance Stat(S2);
//	trace s1, CR, s2, CR;
	trace instance Stat(Delta), CR;
	trace "ProbStudent_t_UnEqueal = ", ProbStudent_t_UnEqueal(s1.Mean, Sqrt(s1.SEM2), s1.DOF, s2.Mean, Sqrt(s2.SEM2), s2.DOF), CR;
	trace "ProbStudent_t = ", ProbStudent_t(s1.Mean, Sqrt(s1.SEM2), s1.DOF, s2.Mean, Sqrt(s2.SEM2), s2.DOF), CR;
	trace CR;
	trace "Start Therapy (AE.Score), 3 Months Therapy (AE.Score)\r\n";

	S1 = << >>;
	S2 = << >>;
	Delta = << >>;
	for (i = 0; i < list->Len(); ++i)
	{
		if (list[i].PatientID == 9594 || list[i].PatientID == 3434 || list[i].PatientID == 8875)
			continue;
		if (list[i].Date->Len() > 1)
		{
			list[i].Date->QSort(<|param key, elem; return key.Date <> elem.Date; |>);
			for (new d = 0; d < list[i].Date->Len(); ++d)
				list[i].Date[d].Tests->QSort(<|param key, elem; return key->GetTestOrder() <> elem->GetTestOrder(); |>);
			trace Printf("%g, %g\r\n",// list[i].PatientID,
										list[i].Date[0]->GetAEScore() * 2, list[i].Date[1]->GetAEScore() * 2);
			S1 ,= list[i].Date[0]->GetAEScore();
			S2 ,= list[i].Date[1]->GetAEScore();
			Delta ,= list[i].Date[0]->GetAEScore() - list[i].Date[1]->GetAEScore();
		}
	}
	s1 = instance Stat(S1);
	s2 = instance Stat(S2);
//	trace s1, CR, s2, CR;
	trace instance Stat(Delta), CR;
	trace "ProbStudent_t_UnEqueal = ", ProbStudent_t_UnEqueal(s1.Mean, Sqrt(s1.SEM2), s1.DOF, s2.Mean, Sqrt(s2.SEM2), s2.DOF), CR;
	trace "ProbStudent_t = ", ProbStudent_t(s1.Mean, Sqrt(s1.SEM2), s1.DOF, s2.Mean, Sqrt(s2.SEM2), s2.DOF), CR;
	trace CR;
	trace "Start Therapy (Op.RedScore), 3 Months Therapy (Op.RedScore)\r\n";

	S1 = << >>;
	S2 = << >>;
	Delta = << >>;
	for (i = 0; i < list->Len(); ++i)
	{
		if (list[i].PatientID == 9594 || list[i].PatientID == 3434 || list[i].PatientID == 8875)
			continue;
		if (list[i].Date->Len() > 1)
		{
			list[i].Date->QSort(<|param key, elem; return key.Date <> elem.Date; |>);
			for (new d = 0; d < list[i].Date->Len(); ++d)
				list[i].Date[d].Tests->QSort(<|param key, elem; return key->GetTestOrder() <> elem->GetTestOrder(); |>);
			trace Printf("%g, %g\r\n",// list[i].PatientID,
										list[i].Date[0]->GetOpRScore(), list[i].Date[1]->GetOpRScore());

			S1 ,= list[i].Date[0]->GetOpRScore();
			S2 ,= list[i].Date[1]->GetOpRScore();
			Delta ,= list[i].Date[0]->GetOpRScore() - list[i].Date[1]->GetOpRScore();
		}
	}
	s1 = instance Stat(S1);
	s2 = instance Stat(S2);
//	trace s1, CR, s2, CR;
	trace instance Stat(Delta), CR;
	trace "ProbStudent_t_UnEqueal = ", ProbStudent_t_UnEqueal(s1.Mean, Sqrt(s1.SEM2), s1.DOF, s2.Mean, Sqrt(s2.SEM2), s2.DOF), CR;
	trace "ProbStudent_t = ", ProbStudent_t(s1.Mean, Sqrt(s1.SEM2), s1.DOF, s2.Mean, Sqrt(s2.SEM2), s2.DOF), CR;
	trace CR;
	trace "Start Therapy (Syn.Score), 3 Months Therapy (Syn.Score)\r\n";

	S1 = << >>;
	S2 = << >>;
	Delta = << >>;
	for (i = 0; i < list->Len(); ++i)
	{
		if (list[i].PatientID == 9594 || list[i].PatientID == 3434 || list[i].PatientID == 8875)
			continue;
		if (list[i].Date->Len() > 1)
		{
			list[i].Date->QSort(<|param key, elem; return key.Date <> elem.Date; |>);
			for (new d = 0; d < list[i].Date->Len(); ++d)
				list[i].Date[d].Tests->QSort(<|param key, elem; return key->GetTestOrder() <> elem->GetTestOrder(); |>);
			trace Printf("%g, %g\r\n",// list[i].PatientID,
										list[i].Date[0]->GetOpSynScore(), list[i].Date[1]->GetOpSynScore()); 
			S1 ,= list[i].Date[0]->GetOpSynScore();
			S2 ,= list[i].Date[1]->GetOpSynScore();
			Delta ,= list[i].Date[0]->GetOpSynScore() - list[i].Date[1]->GetOpSynScore();
		}
	}
	s1 = instance Stat(S1);
	s2 = instance Stat(S2);
//	trace s1, CR, s2, CR;
	trace instance Stat(Delta), CR;
	trace "ProbStudent_t_UnEqueal = ", ProbStudent_t_UnEqueal(s1.Mean, Sqrt(s1.SEM2), s1.DOF, s2.Mean, Sqrt(s2.SEM2), s2.DOF), CR;
	trace "ProbStudent_t = ", ProbStudent_t(s1.Mean, Sqrt(s1.SEM2), s1.DOF, s2.Mean, Sqrt(s2.SEM2), s2.DOF), CR;
	trace CR;
|>;
//main->OnRecalculateAll();
//main->OnImportOpScore();
//main->OnExportStat();
main->OnExportStat_Split();

