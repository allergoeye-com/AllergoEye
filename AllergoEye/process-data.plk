//===============================================
//===============================================
new MainMenu::OnExportStat(...) = <|

	new list = Odml2Exec("select p from DBPatient as p", << >>);
	trace "Op1, Op2, AE1, AE2, OpR1, OpR2, Syn1, Syn2\r\n";

	for (new i = 0; i < list->Len(); ++i)
	{
		if (list[i].Date->Len() > 1)
		{
			list[i].Date->QSort(<|param key, elem; return key.Date <> elem.Date; |>);
			for (new d = 0; d < list[i].Date->Len(); ++d)
				list[i].Date[d].Tests->QSort(<|param key, elem; return key->GetTestOrder() <> elem->GetTestOrder(); |>);
			trace Printf("%d %g, %g, %g, %g, %g, %g, %g, %g\r\n", list[i].PatientID,
										list[i].Date[0]->GetOpScore(), list[i].Date[1]->GetOpScore(),
										list[i].Date[0]->GetAEScore() * 2, list[i].Date[1]->GetAEScore() * 2,
										list[i].Date[0]->GetOpRScore(), list[i].Date[1]->GetOpRScore(),
										list[i].Date[0]->GetOpSynScore(), list[i].Date[1]->GetOpSynScore()); 
		}
	}
|>;
//===============================================
//===============================================
new MainMenu::OnExportStat_Split(...) = <|


	new list = Odml2Exec("select p from DBPatient as p", << >>);

	trace "Start Therapy (Op.Score), 3 Months Therapy (Op.Score)\r\n";
	new S1 = << >>;
	new S2 = << >>;
	new Delta = << >>;
	for (new i = 0; i < list->Len(); ++i)
	{
		if (list[i].PatientID == 9594 || list[i].PatientID == 3434 || list[i].PatientID == 8875)
			continue;
		if (list[i].Date->Len() > 1)
		{
			list[i].Date->QSort(<|param key, elem; return key.Date <> elem.Date; |>);
			for (new d = 0; d < list[i].Date->Len(); ++d)
				list[i].Date[d].Tests->QSort(<|param key, elem; return key->GetTestOrder() <> elem->GetTestOrder(); |>);
			trace Printf("%g, %g\r\n", //list[i].PatientID,
										list[i].Date[0]->GetOpScore(), list[i].Date[1]->GetOpScore());
			S1 ,= list[i].Date[0]->GetOpScore();
			S2 ,= list[i].Date[1]->GetOpScore();
			Delta ,= list[i].Date[0]->GetOpScore() - list[i].Date[1]->GetOpScore();
		}
	}
	new s1 = instance Stat(S1);
	new s2 = instance Stat(S2);
//	trace s1, CR, s2, CR;
	trace instance Stat(Delta), CR;
	trace "ProbStudent_t_UnEqueal = ", ProbStudent_t_UnEqueal(s1.Mean, Sqrt(s1.SEM2), s1.DOF, s2.Mean, Sqrt(s2.SEM2), s2.DOF), CR;
	trace "ProbStudent_t = ", ProbStudent_t(s1.Mean, Sqrt(s1.SEM2), s1.DOF, s2.Mean, Sqrt(s2.SEM2), s2.DOF), CR;
	trace CR;
	trace "Start Therapy (AE.Score), 3 Months Therapy (AE.Score)\r\n";

	S1 = << >>;
	S2 = << >>;
	Delta = << >>;
	for (i = 0; i < list->Len(); ++i)
	{
		if (list[i].PatientID == 9594 || list[i].PatientID == 3434 || list[i].PatientID == 8875)
			continue;
		if (list[i].Date->Len() > 1)
		{
			list[i].Date->QSort(<|param key, elem; return key.Date <> elem.Date; |>);
			for (new d = 0; d < list[i].Date->Len(); ++d)
				list[i].Date[d].Tests->QSort(<|param key, elem; return key->GetTestOrder() <> elem->GetTestOrder(); |>);
			trace Printf("%g, %g\r\n",// list[i].PatientID,
										list[i].Date[0]->GetAEScore() * 2, list[i].Date[1]->GetAEScore() * 2);
			S1 ,= list[i].Date[0]->GetAEScore();
			S2 ,= list[i].Date[1]->GetAEScore();
			Delta ,= list[i].Date[0]->GetAEScore() - list[i].Date[1]->GetAEScore();
		}
	}
	s1 = instance Stat(S1);
	s2 = instance Stat(S2);
//	trace s1, CR, s2, CR;
	trace instance Stat(Delta), CR;
	trace "ProbStudent_t_UnEqueal = ", ProbStudent_t_UnEqueal(s1.Mean, Sqrt(s1.SEM2), s1.DOF, s2.Mean, Sqrt(s2.SEM2), s2.DOF), CR;
	trace "ProbStudent_t = ", ProbStudent_t(s1.Mean, Sqrt(s1.SEM2), s1.DOF, s2.Mean, Sqrt(s2.SEM2), s2.DOF), CR;
	trace CR;
	trace "Start Therapy (Op.RedScore), 3 Months Therapy (Op.RedScore)\r\n";

	S1 = << >>;
	S2 = << >>;
	Delta = << >>;
	for (i = 0; i < list->Len(); ++i)
	{
		if (list[i].Date->Len() > 1)
		{
			list[i].Date->QSort(<|param key, elem; return key.Date <> elem.Date; |>);
			for (new d = 0; d < list[i].Date->Len(); ++d)
				list[i].Date[d].Tests->QSort(<|param key, elem; return key->GetTestOrder() <> elem->GetTestOrder(); |>);
			trace Printf("%g, %g\r\n",// list[i].PatientID,
										list[i].Date[0]->GetOpRScore(), list[i].Date[1]->GetOpRScore());

			S1 ,= list[i].Date[0]->GetOpRScore();
			S2 ,= list[i].Date[1]->GetOpRScore();
			Delta ,= list[i].Date[0]->GetOpRScore() - list[i].Date[1]->GetOpRScore();
		}
	}
	s1 = instance Stat(S1);
	s2 = instance Stat(S2);
//	trace s1, CR, s2, CR;
	trace instance Stat(Delta), CR;
	trace "ProbStudent_t_UnEqueal = ", ProbStudent_t_UnEqueal(s1.Mean, Sqrt(s1.SEM2), s1.DOF, s2.Mean, Sqrt(s2.SEM2), s2.DOF), CR;
	trace "ProbStudent_t = ", ProbStudent_t(s1.Mean, Sqrt(s1.SEM2), s1.DOF, s2.Mean, Sqrt(s2.SEM2), s2.DOF), CR;
	trace CR;
	trace "Start Therapy (Syn.Score), 3 Months Therapy (Syn.Score)\r\n";

	S1 = << >>;
	S2 = << >>;
	Delta = << >>;
	for (i = 0; i < list->Len(); ++i)
	{
		if (list[i].PatientID == 9594 || list[i].PatientID == 3434 || list[i].PatientID == 8875)
			continue;
		if (list[i].Date->Len() > 1)
		{
			list[i].Date->QSort(<|param key, elem; return key.Date <> elem.Date; |>);
			for (new d = 0; d < list[i].Date->Len(); ++d)
				list[i].Date[d].Tests->QSort(<|param key, elem; return key->GetTestOrder() <> elem->GetTestOrder(); |>);
			trace Printf("%g, %g\r\n",// list[i].PatientID,
										list[i].Date[0]->GetOpSynScore(), list[i].Date[1]->GetOpSynScore()); 
			S1 ,= list[i].Date[0]->GetOpSynScore();
			S2 ,= list[i].Date[1]->GetOpSynScore();
			Delta ,= list[i].Date[0]->GetOpSynScore() - list[i].Date[1]->GetOpSynScore();
		}
	}
	s1 = instance Stat(S1);
	s2 = instance Stat(S2);
//	trace s1, CR, s2, CR;
	trace instance Stat(Delta), CR;
	trace "ProbStudent_t_UnEqueal = ", ProbStudent_t_UnEqueal(s1.Mean, Sqrt(s1.SEM2), s1.DOF, s2.Mean, Sqrt(s2.SEM2), s2.DOF), CR;
	trace "ProbStudent_t = ", ProbStudent_t(s1.Mean, Sqrt(s1.SEM2), s1.DOF, s2.Mean, Sqrt(s2.SEM2), s2.DOF), CR;
	trace CR;
|>;
//=================================================
//
//=================================================
new MainMenu::OnLoadAllData(...) = <|
	new f = instance File(instance GOpenDialog("csv", "", "*.csv|*.csv", self)->Open());
	f->Open("rb");
	new op = f->ReadCSV();
	f->Close();
	new In = << >>;
	new Out = << >>;
	new count = 0;
	for (new i = 0; i < op->Len(); ++i)
	{
		new rec = op[i];
		if (rec->Len() < 3 || rec[2]->IsNumber() == FALSE)
			continue;
		new id = int(rec[3]);
		new s_index = int(rec[2]) - 1;
		new study = Odml2Exec("select p.Date[index] from DBPatient as p where p.PatientID = ? order by p.Date[index].Date", << id >>);
		if (study->Len() > s_index)
		{
			new Allegrens = study[s_index]->GetAllergenList();
			for (new k = 0; k < Allegrens->Len(); ++k)
			{
				new offsetAER = EMPTY;
				new offsetAEL = EMPTY;
				new offsetOpV = EMPTY;

				new offsetOp = 0.0;
				new count = 0;
				
				new tests = study[s_index]->GetTestList(Allegrens[k]);
				tests->QSort(<|param key, elem; return key->GetTestOrder() <> elem->GetTestOrder(); |>);

				if (tests[1]->GetTestOrder() == 0 && tests[1].OpScoreV != EMPTY)
				{
					offsetOp = tests[1].OpScore;
					offsetOpV = instance MVector(tests[1].OpScoreV);
					offsetAEL = tests[1].AEScoreL - tests[1].AEScoreR;
					offsetAER = tests[1].AEScoreR - tests[1].AEScoreL;
				}
				else
				if (tests[0]->GetTestOrder() <= 0 && tests[0].OpScoreV != EMPTY)
				{
					offsetOp = tests[0].OpScore;
					offsetOpV = instance MVector(tests[0].OpScoreV);
					offsetAEL = tests[0].AEScoreL - tests[0].AEScoreR;
					offsetAER = tests[0].AEScoreR - tests[0].AEScoreL;
				}
				for (new j = 0; j < tests->Len(); ++j)
				{
					new r = tests[j]->GetTestOrder();
					if (r > 0 && tests[j].OpScoreV != EMPTY)
					{
						new op = ((tests[j].OpScore - offsetOp) >= 3) ? 1.0 : 0.0;
						trace Printf("%03d, %s\r\n", Out->Len() + 1, tests[j].Path);
						new _index = study[s_index].Tests->Find(tests[j].oID, 0, {|param key, elem; return key == elem.oID; |});
						new _in = study[s_index]->GetRelativeDistrMeasurements(_index);
						In ,= ((_in[0][0]- _in[0][2]) * 100.0).Y @ ((_in[0][1] - _in[1][1]) * 100.0).Y;
						new u = instance Vector(instance MVector(tests[j].OpScoreV) - offsetOpV);
						new v = instance Vector(4, u->Len());
						for (new s = 0; s < u->Len(); ++s)
						{
							new index = Min(3, Max(0, u[s]));
							for (new k = 0; k < 4; ++k)
								v[k][s] = 0.0;
							v[index][s] = 1.0;
						}
						Out ,= v;
					}
				}
			}
		}
		else
			stop;
	}
	return << In, Out >>;
|>;
//=================================================
//
//=================================================
/*new PNN::InitAEScore(int, int) = <|
param nIn, nOut;
	.nClasses = 2;
	.IsComplementary = TRUE;
	.GetSample = PNN::GetSample_N;
	.GetLabel = PNN::GetSample_N;
	new LayersList = <<
		//input
		<< 0, << nIn >> >>,
		<< "NeuronDenseSet", << nIn, nIn / 2 >>, 0, 2 >>,
		<< 2, << nIn / 2 >> >>,
		<< "NeuronActFuncSet", <<"RELU", nIn / 2 >>, 2, 3 >>,
		<< 3, << nIn / 2 >> >>,
		<< "NeuronDenseSet", << nIn / 2, nIn / 4 >>, 3, 4 >>,
		<< 4, << nIn / 4 >> >>,
		<< "NeuronActFuncSet", <<"RELU", nIn / 4 >>, 4, 5 >>,
		<< 5, << nIn / 4 >> >>,
		<< "NeuronDenseSet", << nIn / 4, nOut >>, 5, 6 >>,
		<< 6, << nOut >> >>,
		<< "NeuronActFuncSet", << "SOFTMAX", nOut >>, 6, 7 >>,
		<< 7, << nOut >> >>,
		<< "NeuronLossFuncSet", << "CROSSENTROPY", nOut >>, 7, 8 >>,
		<< 8, << nOut >> >>
	>>;
	self->Build(LayersList);
|>;*/
new PNN::InitAEScore(int, int, int) = <|
param nIn, nOut, outNC;
	.nClasses = 4;
	.IsComplementary = TRUE;
	.GetSample = PNN::GetSample_N;
	.GetLabel = PNN::GetSample_N2;
	new LayersList = <<
		//input
		<< 1, << nIn >> >>,
		<< "NeuronConv1DSet", <<1, 5,  4>>, 1, 2 >>,
		<< 2, << 4, nIn >> >>,
		<< "NeuronActFuncSet", <<"RELU", 4 >>, 2, 3 >>,
		<< 3, << 4, nIn >> >>,
		<< "NeuronMaxPool2x2Set", << 4 >>, 3, 4 >>,
		<< 4, << 4, nIn / 2 >> >>,

		<< "NeuronConv1DSet", <<4, 3, 4>>, 4, 5 >>,
		<< 5, << 4, nIn / 2 >> >>,
		<< "NeuronActFuncSet", <<"RELU", 4 >>, 5, 6 >>,
		<< 6, << 4, nIn / 2 >> >>,
		<< "NeuronMaxPool2x2Set", << 4 >>, 6, 7 >>,
		<< 7, << 4, nIn / 4 >> >>,

		<< "NeuronDenseSet", << 4 * (nIn / 4), 2 * nOut * outNC >>, 7, 8 >>,
		<< 8, << 2 * nOut * outNC >> >>,
		<< "NeuronActFuncSet", <<"RELU", 2 * nOut * outNC >>, 8, 9 >>,
		<< 9, << 2 * nOut * outNC >> >>,
		<< "NeuronDenseSet", << 2 * nOut * outNC, nOut * outNC >>, 9, 10 >>,
		<< 10, << nOut, outNC >> >>,
		<< "NeuronActFuncSet", << "SOFTMAX", outNC >>, 10, 11 >>,
		<< 11, << outNC, nOut >> >>,
		<< "NeuronLossFuncSet", << "L2", outNC >>, 11, 12 >>,
		<< 12, << outNC, nOut >> >>
	>>;
	self->Build(LayersList);
|>;
