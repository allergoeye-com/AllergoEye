new str = "Andreitseva Olena 	1	1.5
Ayari Mehrez	2	3.75
Ayari Mehrez   	1	3
Blümel Steve	1	3.666666667
Blümel Steve	2	2.333333333
Clauß Michael	1	4
Clauß Michael	2	1.75
Danylyuk Olena	1	3.25
Danylyuk Olena	2	1.75
Döring Aline	1	1.75
Döring Aline	2	2.75
Ducke Nicole	1	3
Ducke Nicole	2	0.75
Emils Japins	1	4.666666667
Faut Ganna	1	2.75
Faut Ganna	1	0.5
Franke Florian	1	4.5
Gerk1 Rainer Milbe  p. 	1	1.5
Gerk Rainer Milbe t.	1	0
Grismajer Martin	1	2.25
Grismajer Martin	2	1
Haenel Sindy	2	5.666666667
Haenel Sindy	3	4.666666667
Haenel Sindy 	1	6.5
Jany Daniela	1	3
Jany Daniela	2	2.75
Jany Daniela	3	1.5
Jurenz Christiane	1	6
Jurenz Christiane	2	5.333333333
Jurenz Christiane	3	2
Krolichin Olga	1	2.5
Krutsch Larissa 	1	8
Kulisinski Axel	2	1
Kulisinski Axel	1	3.25
Lotze1 Charlotte Milbe p.	1	2.75
Lotze Charlotte Milbe t.	1	1.75
Meinecke Felix	1	4
Moor1 Ina Milbe p. 	1	4
Moor Ina Milbe t.	1	2.25
Richter Thomas	1	3.666666667
Richter Thomas	2	4.75
Richter Thomas	3	4.75
Romashkevychus Alina	1	2.5
Romashkevychus Alina	2	2
Safonova Katharina	1	0.666666667
Schmidt Maximilian 	1	3.5
Schubert1 Conrad Milbe p.	1	0
Schubert Conrad Milbe t.	1	0
Schulze Sophia 	1	4.666666667
Schulze Sophia 	2	1.25
Schulze Sophia 	3	1
Solovyev Vladislav	2	2.5
Solvyev Vladislav 	1	2.5
Sunagawa Yoko	1	5.333333333
Sunagawa Yoko 	2	2.5
Sunagawa Yoko 	3	4.25
Suprun Svitlana	2	3
Suprun Svitlana 	1	6
Tittlowitz Ulrike	1	3.75
Tittlowitz Ulrike 	2	0
Wolf Maria	2	2.25
Wolf Maria 	1	2.666666667
Yehipko Vyacheslav	1	3.666666667
Zimmermann Tom	2	1.75";

global Scores = str->Tokenize(CR);
for (new i = 0; i < Scores->Len(); ++i)
{
	Scores[i] = Scores[i]->Tokenize("\t");
	Scores[i][0] = Scores[i][0]->Tokenize(" ");
	Scores[i][1] = << int(Scores[i][1]), float(Scores[i][2]) >>;
	Scores[i]->SetLen(2); 
}
Scores->QSort();
trace Scores->Len(), CR;
for (i = Scores->Len() - 1; i > 0; --i)
{
	if (Scores[i][0] == Scores[i - 1][0])
	{
		Scores[i - 1][1] ,= Scores[i][1];
		Scores->Remove(i);
	}
}
trace Scores->Len(), CR;


////////////////////////////////////////////////////////////////////////
/*

		 .AllRecord @= << << Name, Familie, Date, ID, &.ListCard[i].parent, CLR_BLACK>> >>;
		if (N != .AllRecord->Len())
		{

			.AllRecord->QSort({|param key, elem; return (key[SelectDlg::NAME] @ key[SelectDlg::FAMILY])  <> (elem[SelectDlg::NAME] @ elem[SelectDlg::FAMILY]);|});
			for (i = 0, l = .AllRecord->Len(); i < l; ++i)
			{
				if (.AllRecord[i][.USED]->Len() == 0)
				self->FromSelectAll(i);
			}
		}


//==================================================
//
//==================================================
new SelectDlg::ImportToDb(void) = <|
	for (new i = 0; i < .AllRecord->Len(); ++i)
	{
		new p = instance Patient();
		p.FirstName = .AllRecord[i][1];
		p.LastName = .AllRecord[i][0];
		p.DateOfBirth = instance Date(.AllRecord[i][2]);
		p.PatientIDStr = .AllRecord[i][3];
		p.PathToRecord = .AllRecord[i][5]->GetPath();
		new old_p = Odml2Exec("select p from Patient as p where p.PathToRecord = ?", << p.PathToRecord >>);
		if (old_p == << >>)
			p->Save();
	}
|>;
opp->ImportToDb();

trace Odml2Exec("select p from Patient as p where p.LastName like ?", << "Kr%" >>), CR;
trace Odml2Exec("select p from Patient as p order by p.LastName", <<  >>), CR;
trace Odml2Exec("select p from Patient as p where p.LastName like ? order by p.PatientIDStr", << "K%" >>), CR;

trace Odml2Exec("select p from Patient as p where p.LastName like ? order by p.PatientIDStr", << "K%" >>), CR;
trace Odml2Exec("select p  from Patient p where p.Date[Index1].Date = ?", << instance Date("11/05/2021") >>), CR;

trace Odml2Exec("select p  from Patient p where p.Date[Index1].Date = ?", << instance Date("11/05/2021") >>), CR;
trace Odml2Exec("select p  from Patient p where p.Date[Index1].Tests[Index2].Allergen = ?", << "Bir%" >>), CR;
trace Odml2Exec("select p  from Patient p where p.Date[Index1].Tests[Index2].Allergen = ? AND p.Date[Index1].Date = ?", << "Bir%", instance Date("05/04/2021") >>), CR;


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


select p  from Patient p where p.Date[Index1].Tests[Index2].Allergen = ? 


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


*/






//================================================
//
//================================================
new SelectDlg::OnCalculateAll(refer ...) = <|
	onerror {
		.waitCursor = EMPTY;
		return;
	};
	self->EnableSync(FALSE);
	self->EnableItem(ID_BUILD, FALSE);
	self->EnableItem(ID_EXCEL, FALSE);
	self->EnableItem(BTN_EDIT, FALSE);
	self->EnableItem(ID_REPORT, FALSE);
	
	.View = &self;
	
	new Dir = AllergoEyeIni->ReadStr("DIR", "DATA");
	if (Dir->GetLastByte() != FD)
		Dir @= SFD;
	for (new i = 0; i < .AllRecord->Len(); ++i)
	{
		.IndexAll = i;
		self->OnSelectAll();
		self->UpdateForm();
		new Patient = &.AllRecord[i][.OBJ];
		if (Patient.name == EMPTY || Patient.name == "")
			continue;
		new name = Patient.name->Tokenize("_");
		new index = Scores->Find(<< name[0], name[1] >>, 0, {|param key, elem; return key[0] == elem[0][0] && key[1] == elem[0][1]; |});
		new score = Scores[index];
		for (new j = 0; j < Patient.childs->Len(); ++j)
		{
			new Exam = &.AllRecord[i][.OBJ].childs[j];
			if (typeof(*Exam) != "DirNode")
				continue;
			new NameList = << >>;
			new str = "";
			for (new k = 0; k < Exam.childs->Len(); ++k)
			{
				new Test = &Exam.childs[k];
				new TestName = Test.name->Tokenize("_");
				new Score0;
				if (TestName->Len() < 2)
					continue;
				switch (TestName[1]->ToLower())
				{
				case "stock solution" :
					Score0 = 0.0;
					break;
				case "1-10" :
					Score0 = 1.0;
					break;
				case "1-100" :
					Score0 = 2.0;
					break;
				case "1-1000" :
					Score0 = 3.0;
					break;
				case "control solution" :
					Score0 = -1.0;
					break;
				}
				new dir = AllergoEyeIni->ReadStr("DIR", "DATA");
				if (dir->GetLastByte() != FD)
					dir @= SFD;
				str = "";
				for (new m = 0; m < Test.childs->Len(); ++m)
				{
					if (JustExtension(Test.childs[m].name) == "jpg")
					{
						new Name = dir @ Test.childs[m]->GetWinPath();
						trace Name, CR;
						NameList ,= Name;
						new tdir = instance TreeDir();
						new ptr = <<>>;
						Test.childs[m]->GetPointersPath(ptr);
						str = tdir->MakeXmlFromPoints(ptr);
					}
				}
			}
			new f = instance File(JustDirName(ExeName) @ "ae_exchange.tmp");
			f->Open("wb");
			for (new m = 0; m < NameList->Len(); ++m)
				f->Putv(NameList[m]);
			f->Close();
			main.netDir->Close();
			new s = instance Silent();
			main.netDir.server = instance ToServer("WRITE", "RECALC", main.netDir.serverAddress, str->ANSIToUTF16(), &self);
			do {
				Pluk->Idle();
				Pluk->Delay(1.0);
			}
			while (main.netDir.server != EMPTY);
			s = EMPTY;
		}
	}
	self->EnableItem(ID_BUILD, FALSE);
	self->EnableSync(TRUE);
	self->EnableItem(ID_REPORT, TRUE);
 	self->EnableItem(ID_EXCEL, TRUE);
	self->EnableItem(BTN_EDIT, TRUE);
|>;


//================================================
//
//================================================
new SelectDlg::OnBuildData(refer ...) = <|
	onerror {
		.waitCursor = EMPTY;
		return;
	};
	self->EnableSync(FALSE);
	self->EnableItem(ID_BUILD, FALSE);
	self->EnableItem(ID_EXCEL, FALSE);
	self->EnableItem(BTN_EDIT, FALSE);
	self->EnableItem(ID_REPORT, FALSE);
	
	.View = &self;
	
	new Dir = AllergoEyeIni->ReadStr("DIR", "DATA");
	if (Dir->GetLastByte() != FD)
		Dir @= SFD;
	global AE_Score = instance Vector(Scores->Len(), 0);
	for (new i = 0; i < .AllRecord->Len(); ++i)
	{
		.IndexAll = i;
		self->OnSelectAll();
		self->UpdateForm();
		new Patient = &.AllRecord[i][.OBJ];
		if (Patient.name == EMPTY || Patient.name == "")
			continue;
		new name = Patient.name->Tokenize("_");
		new index = Scores->Find(<< name[0], name[1] >>, 0, {|param key, elem; return key[0] == elem[0][0] && key[1] == elem[0][1]; |});
		new score = Scores[index];
		for (new j = 0; j < Patient.childs->Len(); ++j)
		{
			new Exam = &.AllRecord[i][.OBJ].childs[j];
			if (typeof(*Exam) != "DirNode")
				continue;
			new NameList = << >>;
			new str = "";
			for (new k = 0; k < Exam.childs->Len(); ++k)
			{
				new Test = &Exam.childs[k];
				new TestName = Test.name->Tokenize("_");
				new Score0 = -2, side = 0;
				if (TestName->Len() < 3)
					continue;
				if (TestName[2] == "links" || TestName[2] == "left")
					side = 1;
				else
				if (TestName[2] == "rechts" || TestName[2] == "right")
					side = 0;
				else
					side = 0;
				switch (TestName[1]->ToLower())
				{
				case "stock solution" :
					Score0 = 3.0;
					break;
				case "1-10" :
					Score0 = 2.0;
					break;
				case "1-100" :
					Score0 = 1.0;
					break;
				case "1-1000" :
					Score0 = 0.0;
					break;
				case "control solution" :
					Score0 = -1.0;
					break;
				case "entrance examination" :
				case "start test" :
					Score0 = -1.0;
					break;
				}
				new dir = AllergoEyeIni->ReadStr("DIR", "DATA");
				if (dir->GetLastByte() != FD)
					dir @= SFD;
				str = "";
				for (new m = 0; m < Test.childs->Len(); ++m)
				{
					if (JustExtension(Test.childs[m].name) == "dst")
					{
						new Name = dir @ Test.childs[m]->GetWinPath();
						trace Name, CR;
						new f0 = instance File(Name);
						f0->Open("rb");
						new n1 = AE_Score[index]->BFind(j, {|param key, elem; return key <> elem[0]; |});
						if (n1 < 0)
							n1 = AE_Score[index]->BInsert(<< j, << >> >>, {|param key, elem; return key[0] <> elem[0]; |});
						new n = AE_Score[index][n1][1]->BFind(Score0, {|param key, elem; return key <> elem[0]; |});
						if (n < 0)
							AE_Score[index][n1][1]->BInsert(<< Score0, side, << f0->Getv() >> >>, {|param key, elem; return key[0] <> elem[0]; |});
						else
							AE_Score[index][n1][1][n][2] ,= f0->Getv();
						f0->Close();
					}
				}
			}
		}
	}
	self->EnableItem(ID_BUILD, FALSE);
	self->EnableSync(TRUE);
	self->EnableItem(ID_REPORT, TRUE);
 	self->EnableItem(ID_EXCEL, TRUE);
	self->EnableItem(BTN_EDIT, TRUE);
|>;

/*
main.SelectDlg->OnCalculateAll();

opp.waitCursor = EMPTY;
opp->OnBuildData();
*/

/*
global sAE_Score = AE_Score;


AE_Score = sAE_Score;
for (new i = 0; i < AE_Score->Len(); ++i)
{
	for (new j = 0; j < AE_Score[i]->Len(); ++j)
	{
		new bg = EMPTY;	
		for (new k = AE_Score[i][j][1]->Len() - 1; k >= 0; --k)
		{
			new Score0 = AE_Score[i][j][1][k][0];
			new side = AE_Score[i][j][1][k][1];
			new distr = AE_Score[i][j][1][k][2][0];
			for (new m = 1; m < AE_Score[i][j][1][k][2]->Len(); ++m)
			{
				distr[0][0] += AE_Score[i][j][1][k][2][m][0][0];
				distr[0][1] += AE_Score[i][j][1][k][2][m][0][1];
				distr[1][0] += AE_Score[i][j][1][k][2][m][1][0];
				distr[1][1] += AE_Score[i][j][1][k][2][m][1][1];
			}
			distr[0][0] /= distr[0][0]->Integral(distr[0][0].X[0], distr[0][0].X->Last());
			distr[0][1] /= distr[0][1]->Integral(distr[0][1].X[0], distr[0][1].X->Last());
			distr[1][0] /= distr[1][0]->Integral(distr[1][0].X[0], distr[1][0].X->Last());
			distr[1][1] /= distr[1][1]->Integral(distr[1][1].X[0], distr[1][1].X->Last());
			if (Score0 == -1)
			{
				bg = distr;
				AE_Score[i][j][1]->Remove(k);
			}
			else
			if (Score0 == -2)
			{
				if (bg == EMPTY)
					bg = distr;
				AE_Score[i][j][1]->Remove(k);
			}
			else
			if (Score0 >= 0)
				AE_Score[i][j][1][k][2] = distr;
		}

		for (k = 0; k < AE_Score[i][j][1]->Len(); ++k)
		{
			new side = AE_Score[i][j][1][k][1];
			new distr = AE_Score[i][j][1][k][2];
/*			distr[0][0] -= bg[0][0];
			distr[0][1] -= bg[0][1];
			distr[1][0] -= bg[1][0];
			distr[1][1] -= bg[1][1];*/
			if (side == 1)
				AE_Score[i][j][1][k][2] = << distr[1][0], distr[1][1]>>;
			else
				AE_Score[i][j][1][k][2] = << distr[0][0], distr[0][1]>>;
		}
	}
}

trace "OK", CR;

for (new i = 0; i < AE_Score->Len(); ++i)
{
	for (new j = 0; j < AE_Score[i]->Len(); ++j)
	{
		new Score = 0.0;
		new Red = 0.0;
		new Grad = 0.0;
		new count = 0;
		for (new k = 0; k < AE_Score[i][j][1]->Len(); ++k)
		{
			new red = 0.0;
			new Score0 = AE_Score[i][j][1][k][0];
			new dist_r = AE_Score[i][j][1][k][2][0];
			for (new m = 0; m < dist_r.Y->Len(); ++m)
				red += dist_r.Y[m] * dist_r.X[m];
				
			new dist_grad = AE_Score[i][j][1][k][2][1];
			new grad = 0.0;
			for (m = 0; m < dist_grad.Y->Len(); ++m)
				grad += dist_grad.Y[m] * dist_grad.X[m];
			if (red > 0)
			{
				Score += (red + grad) * (4.0 - Score0);
				Red += red * (4.0 - Score0);
				Grad += grad * (4.0 - Score0);
			}
			++count;
		}
		Score /= count;
		Red /= count;
		Grad /= count;
		trace Printf("%s \t%d \t%g \t%g \t%g\r\n", Scores[i][0]->SynStr(" "), j + 1, Score, Red, Grad);
	}
}

*/
