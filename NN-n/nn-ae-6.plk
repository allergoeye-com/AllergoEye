//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////


//===============================================
/**
param inNC, X, Y, outNC;
**/
//===============================================
new PNNBlock::GetSpec_AE_Encoder(int, int, int, int) = <|
param inNC, X, Y, outNC;
	return <<
		<< 1, << inNC, X, Y >> >>,
		<< 1, "NeuronConv2D", <<inNC, 5, 5, outNC >>, << "RELU", 0.0, "" >>, 1, 2 >>,
		<< 2, << outNC, X, Y >> >>,
		<< 2, "NeuronConv2D", <<outNC, 5, 5, outNC >>, << "RELU", 0.0, "" >>, 2, 3 >>,
		<< 3, << outNC, X, Y >> >>,
		<< 3, "NeuronConv2D", <<outNC, 5, 5, outNC >>, << "RELU", 0.0, "" >>, 3, 4 >>,
		<< 4, << outNC, X, Y >> >>
		>>;
|>;
//===============================================
/**
param inNC, X, Y, outNC;
**/
//===============================================
new PNNBlock::GetSpec_AE_Decoder(int, int, int, int) = <|
param inNC, X, Y, outNC;
	return <<
		<< 1, << inNC, X, Y >> >>,
		<< 1, "NeuronConv2D", <<inNC, 3, 3, outNC >>, << "RELU", 0.0, "" >>, 1, 2 >>,
		<< 2, << outNC, X, Y >> >>,
		<< 2, "NeuronConv2D", <<outNC, 3, 3, outNC >>, << "RELU", 0.0, "" >>, 2, 3 >>,
		<< 3, << outNC, X, Y >> >>,
		<< 3, "NeuronConv2D", <<outNC, 3, 3, outNC >>, << "RELU", 0.0, "" >>, 3, 4 >>,
		<< 4, << outNC, X, Y >> >>
		>>;
|>;

//==============================================
//
//==============================================
NeuronCustom::_PropagateForward(int) = {|
param bSize;
	if (.Params[0] == "MakeMask")
	{
		new X = .Params[2];
		new Y = .Params[3];
		for (new b = 0; b < bSize; ++b)
		{
			new Res = instance FMathImage(X, Y);
			new rect = .InLayer[b]->GetVector()[0];
			rect *= .Params[1];
			Res->SetBar(Max(int(rect[0]) - 2, 0), Max(int(rect[1]) - 1, 0), Min(int(rect[2] + 0.5) + 2, X - 1), Min(int(rect[3] + 0.5) + 1, Y - 1), 0.8);
			Res->SetBar(Max(int(rect[4]) - 2, 0), Max(int(rect[5]) - 1, 0), Min(int(rect[6] + 0.5) + 2, X - 1), Min(int(rect[7] + 0.5) + 1, Y - 1), 0.8);
			Res += 0.2;
			Res->Smooth(2);
			.OutLayer[b]->Load(Res, 0);
		}
	}
	else
	if (.Params[0] == "MakeGMask")
	{
		new X = .Params[2];
		new Y = .Params[3];
		new bin = .Params[1];
		new bin_index = NN.GTBinning->Find(bin);
		for (new b = 0; b < bSize; ++b)
		{
			new Res = instance FMathImage(X, Y);
			new gt = NN.GroundTruth[bin_index][b]->GetVector()[0];
			Res->SetBar(int(gt[0]) - 2, int(gt[1]) - 1, int(gt[2] + 0.5) + 2, int(gt[3] + 0.5) + 1, 0.8);
			Res->SetBar(int(gt[4]) - 2, int(gt[5]) - 1, int(gt[6] + 0.5) + 2, int(gt[7] + 0.5) + 1, 0.8);
			Res += 0.2;
			Res->Smooth(2);
			.OutLayer[b]->Load(Res, 0);
		}
	}
|};

new PNN::BuildAE(int, int) = <|
param X, Y;

	.UseClassWeights = FALSE;
	.GT_type = "Custom";
	.SaveBest = TRUE;
	.TestRep = 3;
	.MaxTestSize = 10;
	.NormilizeSample = FALSE;
	.Name = Printf("NAE-6-bin2b");

	new X2 = X / 2 + (X % 2);
	new Y2 = Y / 2 + (Y % 2);

	new X4 = X2 / 2 + (X2 % 2);
	new Y4 = Y2 / 2 + (Y2 % 2);

	new X8 = X4 / 2 + (X4 % 2);
	new Y8 = Y4 / 2 + (Y4 % 2);

	new X16 = X8 / 2 + (X8 % 2);
	new Y16 = Y8 / 2 + (Y8 % 2);

	new LayersList = <<
			<< 1, << 3, X, Y >> >>,
			<< 10, "NeuronNormalize", 0.99, 1, 10 >>,
			<< 10, << 3, X, Y >> >>,
//			<< 20, "NNBlock", self->GetSpec_AE_Encoder(3, X, Y, 8), 10, 20 >>,
//			<< 20, << 8, X, Y >> >>,
	
			<< 30, "NeuronBlurPool2x2", 3, 10, 30 >>,
			<< 30, << 3, X2, Y2 >> >>,
			<< 40, "NNBlock", self->GetSpec_AE_Encoder(3, X2, Y2, 16), 30, 40 >>,
			<< 40, << 16, X2, Y2 >> >>,

			<< 50, "NeuronBlurPool2x2", 3, 30, 50 >>,
			<< 50, << 3, X4, Y4 >> >>,
			<< 60, "NNBlock", self->GetSpec_AE_Encoder(3, X4, Y4, 32), 50, 60 >>,
			<< 60, << 32, X4, Y4 >> >>,
	
			<< 70, "NeuronBlurPool2x2", 32, 60, 70 >>,
			<< 70, << 32, X8, Y8 >> >>,
			<< 80, "NNBlock", self->GetSpec_AE_Encoder(32, X8, Y8, 64), 70, 80 >>,
			<< 80, << 64, X8, Y8 >> >>,
			
//////////////////////////////////////////////////////////

			<< 90, "NeuronBlurPool2x2", 64, 80, 90 >>,
			<< 90, << 64, X16, Y16 >> >>,
			<<100, "NNBlock", self->GetSpec_AE_Encoder(64, X16, Y16, 128), 90, 100 >>,
			<<100, << 128, X16, Y16 >> >>,

			<<110, "NeuronConv2D", << 128, 5, 5, 128 >>, << "RELU", 0.0, "" >>, 100, 110 >>,
			<<110, << 128, X16, Y16 >> >>,

			<<170, "NeuronConv2D", <<128, 3, 3, 32 >>, << "RELU", 0.0, "" >>, 110, 170 >>,
			<<170, << 32, X16, Y16 >> >>,
	
			<<175, "NeuronConvC", <<32, 3 >>, << "SOFTMAX", 0.0, "" >>, 170, 175 >>,
			<<175,	<< 3, X16, Y16 >> >>,

		<<180, "NeuronLossFunc", "CROSSENTROPY_BINARY", << >>, << 2, 16, 10.0 >>, 175, 180  >>,
			<<180, << 3, X16, Y16 >> >>,


//////////////////////////////////////////////////////////
// 	<< "BlockBackPropagation" >>,
			<<182, "NeuronForkB", 175, 182 >>,
			<<182,	<< 3, X16, Y16 >> >>,
			<<183, "NeuronForkB", 170, 183 >>,
			<<183,	<<32, X16, Y16 >> >>,
			<<184, "NeuronForkB", 80, 184 >>,
			<<184,	<< 64, X8, Y8 >> >>,

			<<185, "NeuronUpSize2x2", 3, 182, << 190, 96, 3 >> >>,
			<<187, "NeuronUpSize2x2", 32, 183, << 190, 0, 32 >> >>,
			<<190, "NeuronNormalize", 1.0,184, <<190, 32, 64 >> >>,
			<<190, <<99, X8, Y8 >> >>,
			
			<<210, "NNBlock", self->GetSpec_AE_Decoder(99, X8, Y8, 64), 190, 210 >>,
			<<210, << 64, X8, Y8 >> >>,

			<<220, "NeuronConv2D", << 64, 3, 3, 32 >>, << "RELU", 0.0, "" >>, 210, 220>>,
			<<220,	<< 32, X8, Y8 >> >>,

			<<230, "NeuronConvC", <<32, 3 >>, << "SOFTMAX", 0.0, "" >>, 220, 230 >>,
			<<230,	<< 3, X8, Y8 >> >>,

		<<240, "NeuronLossFunc", "CROSSENTROPY_BINARY", << >>, << 3, 8, 5.0 >>, 230, 240  >>,
			<<240, << 3, X8, Y8 >> >>,
			
//////////////////////////////////////////////////////////
// 	<< "BlockBackPropagation" >>,

			<<241, "NeuronForkB", 220, 241 >>,
			<<241,	<<32, X8, Y8 >> >>,
			<<242, "NeuronNormalize", 1.0, 241, 242 >>,
			<<242,	<<32, X8, Y8 >> >>,
			<<243, "NeuronForkB", 230, 243 >>,
			<<243,	<< 3, X8, Y8 >> >>,
			<<244, "NeuronForkB", 60, 244 >>,
			<<244,	<< 32, X4, Y4 >> >>,

			<<245, "NeuronUpSize2x2", 3, 243, << 250, 0, 3 >> >>,
			<<247, "NeuronUpSize2x2", 32, 242, << 250, 3, 32 >> >>,
			<<250, "NeuronNormalize", 1.0, 244, << 250, 35, 32 >> >>,
			<<250, <<67, X4, Y4 >> >>,
			
			<<260, "NNBlock", self->GetSpec_AE_Decoder(67, X4, Y4, 64), 250, 260 >>,
			<<260, << 64, X4, Y4 >> >>,

			<<270, "NeuronConv2D", << 64, 3, 3, 32 >>, << "RELU", 0.0, "" >>, 260, 270>>,
			<<270,	<< 32, X4, Y4 >> >>,

			<<280, "NeuronConvC", <<32, 3 >>, << "SOFTMAX", 0.0, "" >>, 270, 280 >>,
			<<280,	<< 3, X4, Y4 >> >>,

		<<290, "NeuronLossFunc", "CROSSENTROPY_BINARY", << >>, << 3, 4, 15.0 >>, 280, 290  >>,
			<<290, << 3, X4, Y4 >> >>,
//////////////////////////////////////////////////////////

//	<< "BlockBackPropagation" >>,

			<<301, "NeuronForkB", 270, 301 >>,
			<<301,	<<32, X4, Y4 >> >>,
			<<302, "NeuronNormalize", 1.0, 301, 302 >>,
			<<302,	<<32, X4, Y4 >> >>,
			<<303, "NeuronForkB", 280, 303 >>,
			<<303,	<< 3, X4, Y4 >> >>,

			<<304, "NeuronForkB", << 250, 0, 3 >>, 304 >>,
			<<304,	<< 3, X4, Y4 >> >>,

			<<305, "NeuronUpSize2x2", 3, 303, << 310, 0, 3 >> >>,
			<<306, "NeuronUpSize2x2", 3, 304, << 310, 3, 3 >> >>,
			<<307, "NeuronUpSize2x2", 32, 302, << 310, 6, 32 >> >>,
			<<310, "NeuronNormalize", 1.0, 40, << 310, 38, 16 >> >>,
			<<310, <<54, X2, Y2 >> >>,

			<<320, "NNBlock", self->GetSpec_AE_Decoder(54, X2, Y2, 32), 310, 320 >>,
			<<320, << 32, X2, Y2 >> >>,
			<<330, "NeuronConv2D", << 32, 3, 3, 32 >>, << "", 0.0, "" >>, 320, 330>>,
			<<330,	<< 32, X2, Y2 >> >>,
			<<340, "NeuronConvC", <<32, 3 >>, << "SOFTMAX", 0.0, "" >>, 330, 340 >>,
			<<340,	<< 3, X2, Y2 >> >>,
	
		<<350, "NeuronLossFunc", "CROSSENTROPY_BINARY", << >>, << 3, 2, 25.0 >>, 340, 350  >>,
			<<350, << 3, X2, Y2 >> >>,

			<< "ExitNN", << 340,  2 >> >>,
			<< "ExitNN", << 280,  4 >> >>,
			<< "ExitNN", << 230,  8 >> >>,
			<< "ExitNN", << 175, 16 >> >>
		>>;
	self->Build(LayersList);
	if (.UseOCL)
		self->InitOCLMem();

|>;

PNN::Cache_Name = << >>;
PNN::Cache_Image = << >>;

new PNN::InitAE(void) = <|
 new X = 1200;
 new Y = 316;
	new X2 = X / 2 + (X % 2);
	new Y2 = Y / 2 + (Y % 2);

	new X4 = X2 / 2 + (X2 % 2);
	new Y4 = Y2 / 2 + (Y2 % 2);

	new X8 = X4 / 2 + (X4 % 2);
	new Y8 = Y4 / 2 + (Y4 % 2);

	new X16 = X8 / 2 + (X8 % 2);
	new Y16 = Y8 / 2 + (Y8 % 2);

	.GetSample = Printf({|
		param Self, Samples;
		
		new Name = Samples[0][Samples[1]];
		if (PNN::Cache_Name == EMPTY)
			PNN::Cache_Name = << >>;
		new index = PNN::Cache_Name->BFind(Name);
		if (index == -1)
		{
			index = PNN::Cache_Name->BInsert(Name);
			new Images = MathImage::LoadImageSet(Name);
			new W = %d;
			new H = %d;
			if (W != Images[0]->Width() || H != Images[0]->Height())
			{
				for (new i = 0; i < Images->Len(); ++i)
					Images[i] = Images[i]->Stretch(0.0, W, H);
			}
			new W2 = W / 2 + (W %% 2);
			new H2 = H / 2 + (H %% 2);
			new W4 = W2 / 2 + (W2 %% 2);
			new H4 = H2 / 2 + (H2 %% 2);
			new W8 = W4 / 2 + (W4 %% 2);
			new H8 = H4 / 2 + (H4 %% 2);
			new W16 = W8 / 2 + (W8 %% 2);
			new H16 = H8 / 2 + (H8 %% 2);
			new mask_l = Images[4];
			mask_l |= Images[5];
			new mask_r = mask_l;
			new rect = mask_l->GetNonZeroRect();
			new cx = (rect.left + rect.right) / 2;
			mask_r->SetBar(0, 0, cx, H, 0);
			mask_l->SetBar(cx, 0, W, H, 0);
			new rect_l = mask_l->GetNonZeroRect();
			new rect_r = mask_r->GetNonZeroRect();
			new sx = float(W16) / float(W);
			new sy = float(H16) / float(H);
			new Rect = instance NNBufferF(1, 8);
			
			Rect->Copy(<< Max(0, rect_l.left * sx - 2), Max(0, rect_l.top * sy - 1), Min(W16, rect_l.right * sx + 2), Min(H16, rect_l.bottom * sy + 1),
						  Max(0, rect_r.left * sx - 2), Max(0, rect_r.top * sy - 1), Min(W16, rect_r.right * sx + 2), Min(H16, rect_r.bottom * sy + 1) >>, 0);

			new Src = instance Vector(3);
			for (new i = 0; i < Src->Len(); ++i)
				Src[i] = instance FMathImage(Images[i]);

			new Label1 = instance Vector(3);
			for (i = 0; i < Label1->Len(); ++i)
			{
				Label1[i] = instance FMathImage(Images[i + 3]);
//				Label1[i]->Smooth(1);
			}

			new Label2 = instance Vector(3);
			for (i = 0; i < Label2->Len(); ++i)
			{
				Label2[i] = Label1[i]->Stretch(0.0, W2, H2);
//				Label2[i]->Smooth(4);
			}

			new Label4 = instance Vector(3);
			for (i = 0; i < Label4->Len(); ++i)
			{
				Label4[i] = Label2[i]->Stretch(0.0, W4, H4);
//				Label4[i]->Smooth(3);
			}

			new Label8 = instance Vector(3);
			for (i = 0; i < Label8->Len(); ++i)
			{
				Label8[i] = Label4[i]->Stretch(0.0, W8, H8);
//				Label8[i]->Smooth(2);
			}

			new Label16 = instance Vector(3);
			for (i = 0; i < Label16->Len(); ++i)
			{
				Label16[i] = Label8[i]->Stretch(0.0, W16, H16);
//				Label16[i]->Smooth(1);
			}

			new cache = << instance NNBufferF(Src),
						instance NNBufferF(Label1),
						instance NNBufferF(Label2),
						instance NNBufferF(Label4),
						instance NNBufferF(Label8),
						instance NNBufferF(Label16),
						Rect
						>>;
			if (PNN::Cache_Image == EMPTY)
			{
				PNN::Cache_Image = << EMPTY >>;
				PNN::Cache_Image[0] <- cache;
			}
			else
			{
				PNN::Cache_Image->Insert(EMPTY, index);
				PNN::Cache_Image[index] <- cache;
			}
		}
		return PNN::Cache_Image[index][0];
	|}, X, Y);
	
	.GetLabel = {|
		param Self, Samples;
		parest Binning;
		new Name = Samples[0][Samples[1]];
		new index = PNN::Cache_Name->BFind(Name);
		new bin = Binning == << >> ? 1 : Binning[0];

		switch (bin)
		{
		case 1 :
			return PNN::Cache_Image[index][1];
		case 2 :
			return PNN::Cache_Image[index][2];
		case 4 :
			return PNN::Cache_Image[index][3];
		case 8 :
			return PNN::Cache_Image[index][4];
		case 16 :
			return PNN::Cache_Image[index][5];
		case 17 :
			return PNN::Cache_Image[index][6];
		}	
	|};
	
	.CustomCompare = Printf({|
		param binning, b, Self;
		new bin_index = Self.GTBinning->Find(binning);
		new res;

		if (binning == 17)
		{
			res = Self->GetResultLayer(binning)[b]->GetVector()[0];
			new gt = Self.GroundTruth[bin_index][b]->GetVector()[0];
			new X16 = %d;
			new Y16 = %d;
			new Src = instance MathImage(X16, Y16);
			Src->SetBar(int(res[0]), int(res[1]), int(res[2] + 0.5), int(res[3] + 0.5), 1);
			Src->SetBar(int(res[4]), int(res[5]), int(res[6] + 0.5), int(res[7] + 0.5), 1);
			new Dst = instance MathImage(X16, Y16);
			Dst->SetBar(int(gt[0]), int(gt[1]), int(gt[2] + 0.5), int(gt[3] + 0.5), 1);
			Dst->SetBar(int(gt[4]), int(gt[5]), int(gt[6] + 0.5), int(gt[7] + 0.5), 1);
			new Src_and_Dst = Src;
			Src_and_Dst &= Dst;
			new Src_or_Dst = Src;
			Src_or_Dst |= Dst;
			new nom = Src_and_Dst->Integral(0, 0, X16, Y16);
			new denom = Src_or_Dst->Integral(0, 0, X16, Y16);
			if (denom > 0)
				return float(nom) / float(denom);
			else
				return 0.0;
		}
		else
		if (binning <= 16 && binning > 1)
		{
			res = Self->GetResultLayer(binning)[b];
			return res->CompareClassMasks(*&Self.GroundTruth[bin_index][b]);
		}
		return;
	|}, X16, Y16);
	self->BuildAE(X, Y);
|>;

