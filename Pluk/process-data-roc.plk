//=================================================
//
//=================================================
new MainMenu::CalculateROC(void) = <|
	new X = << >>;
	new Y = << >>;
	new AE = << >>;
	new XR = << >>;

	new PatientsID = Odml2Exec("select p.PatientID from DBPatient as p", <<  >>);

	new sets = instance Vector(5, 0);
	new op_sets = instance Vector(5, 0);
	new ae_sets = instance Vector(5, 0);
	new opR_sets = instance Vector(5, 0);
	for (new i = 0; i < PatientsID->Len(); ++i)
	{
		new study = Odml2Exec("select p.Date[index] from DBPatient as p where p.PatientID = ? order by p.Date[index].Date", << PatientsID[i] >>);
		for (new s_index = 0; s_index < study->Len(); ++s_index)
		{
//			trace "------------------------ ", CR, study[s_index].Path, CR, CR;
			new Allegrens = study[s_index]->GetAllergenList();
			for (new k = 0; k < Allegrens->Len(); ++k)
			{
				new tests = study[s_index]->GetTestList(Allegrens[k]);
				tests->QSort(<|param key, elem; return key->GetTestOrder() <> elem->GetTestOrder(); |>);
				new offsetL = EMPTY;
				new offsetR = EMPTY;
				new offsetOp = EMPTY;
				new offsetOpR = EMPTY;
				new offsetAER = EMPTY;
				new offsetAEL = EMPTY;
				if (tests->Len() < 3)
					continue;
				if (tests[1]->GetTestOrder() == 0 && tests[1].OpScoreV != EMPTY)
				{
					tests[1]->CalculateScore();
					offsetOp = tests[1].OpScore;
					offsetOpR = tests[1].OpScoreV[3];
					offsetAEL = tests[1].AEScoreL - tests[1].AEScoreR;
					offsetAER = tests[1].AEScoreR - tests[1].AEScoreL;
				}
				else
				if (tests[0]->GetTestOrder() < 0 && tests[0].OpScoreV != EMPTY)
				{
					tests[0]->CalculateScore();
					offsetOp = tests[0].OpScore;// tests[0].OpScoreV[0] + tests[0].OpScoreV[1] + tests[0].OpScoreV[2];
					offsetOpR = tests[0].OpScoreV[3];
					offsetAEL = tests[0].AEScoreL - tests[0].AEScoreR;
					offsetAER = tests[0].AEScoreR - tests[0].AEScoreL;
				}
				else
					continue;
	
				for (new j = 0; j < tests->Len(); ++j)
				{
					if (tests[j]->GetTestOrder() <= 0)
						continue;
					tests[j]->CalculateScore();
					if (tests[j].OpScoreV != EMPTY)
					{
						new op, opR, ae;
						opR = tests[j].OpScoreV[3] - offsetOpR;
						op =  Max(0.0, tests[j].OpScore - offsetOp);
						ae = tests[j].AEScoreL - tests[j].AEScoreR - offsetAEL;
						X ,= op;
						XR ,= opR;
						AE ,= Max(Rand(0.01), ae);
						new d_index = tests[j]->GetTestOrder();
						if (d_index == -1)
							continue;
						if (d_index <= 0)
							d_index = 0;
						else
							d_index -= 2;
						op_sets[d_index] ,= op;
						ae_sets[d_index] ,= ae;
						opR_sets[d_index] ,= opR;
						if (ae >= 0.3 && XR->Last() == 0)
						{
							trace "------------------------ ", CR, study[s_index].Path, CR, CR;
							trace Printf("FP: %s %s %v op = %g, opR = %g, ae = %g\r\n", tests[j].Allergen.Allergen, tests[j].Allergen.Dil, tests[j].OpScoreV, op, opR, ae);
						}
						if (ae < 0.3 && XR->Last() >= 1)
						{
							trace "------------------------ ", CR, study[s_index].Path, CR, CR;
							trace Printf("FN: %s %s %v op = %g, opR = %g, ae = %g\r\n", tests[j].Allergen.Allergen, tests[j].Allergen.Dil, tests[j].OpScoreV, op, opR, ae);
						}
					}
				}
			}
		}
	}
	global sgraph;
	if (sgraph == EMPTY || !sgraph->IsOpen())
		sgraph = instance ScatterPlotGrphWnd();
//	sgraph->AddCurve(instance ScatterPlot(X, AE, "OpScore-X, AE-Red-Y"));
	sgraph->AddCurve(instance ScatterPlot(XR, AE, "OpRed-X, AE_Red-Y"));

	global roc_graph;
	if (roc_graph == EMPTY || !roc_graph->IsOpen())
		roc_graph = instance GraphicWnd();
	new nTP = 0.0;
	new nFP = 0.0;
	new ROC = instance Vector(X->Len());
	for (new k = 0; k < X->Len(); ++k)
	{
//		if (X[k] >= 3 && XR[k] > 0)
		if (XR[k] > 0)
			nTP += 1.0;
		else
			nFP += 1.0;
		ROC[k] = << AE[k], X[k], XR[k] >>;
	}
	ROC->QSort({| param key, elem; return key[0] <> elem[0]; |});
	new _ROC = << << 1.0, 1.0, ROC->Last()[0] ** 2.0 + 0.5 >> >>;
	new tp = 1.0;
	new fp = 1.0;
	for (new t = 0; t < ROC->Len(); ++t)
	{

//		if (ROC[t][1] >= 3 && ROC[t][2] > 0)
		if (ROC[t][2] > 0)
			tp -= 1.0 / nTP;
		else
			fp -= 1.0 / nFP;
		_ROC ,= << fp, tp, ROC[t][0] ** 2.0 >>;
	}
	_ROC->QSort();
	new ROC_X = instance Vector(_ROC->Len());
	new ROC_Y = instance Vector(_ROC->Len());
	new ROC_D = instance Vector(_ROC->Len());
	for (k = 0; k < _ROC->Len(); ++k)
	{
		ROC_X[k] = _ROC[k][0] * 100.0;
		ROC_Y[k] = _ROC[k][1] * 100.0;
		ROC_D[k] = _ROC[k][2];
	}
	new rc = instance Curve(ROC_X, ROC_Y, ROC_D);
	roc_graph->AddCurve(rc);
//	return self->SaveToCSV(sets, op_sets, ae_sets, opR_sets);
|>;
main->CalculateROC();
