
new BetaCurve::RebuildEx(int) = {|
param REBUILD_LEN;
	if ( REBUILD_LEN < 5 )
		REBUILD_LEN = 5;
	self->GetContour();
	new P = .Contour;
	self->Init(P, .skew, .tension );
	self->GetContour();

	new vec = instance Vector(4 * REBUILD_LEN);
	new st = self->GetLength() / REBUILD_LEN;
	new step0 = 1.0 / .Contour->Len();
	new step = 1.0 / REBUILD_LEN;
	new mu0 = 0.0;
	new mu = step0;
	new pos = 0.0;
	new pos1 = st;
    new realpos = 0.0;

	vec[0] = self(0.0);
	for ( new i = 1; mu < 1.0; ++i)
	{
		new delta = step;
		new flg = -1;
		new cnt = 1.0;
		while (TRUE)
        {
			vec[i] = self(mu);
			if ((vec[i] - vec[i - 1])->Module() > st || cnt - (vec[i] - vec[i - 1])->Module() > 2.0)
				break;
			mu += step0;

			if (mu >= 1.0)
				break;
			mu += step0;
			if (mu > 1.0)
				mu = 1.0;
		}
	}
	vec->SetLen(i);
//	self->Init( vec, .skew, .tension );
	.A = vec;
	self->GetContour();
|};

class NNGlobal {
	NN;
};
global wnd;
//=======================================
//
//=======================================
new NNGlobal::NNGlobal(void) = <|
|>;
//=======================================
//
//=======================================
new NNGlobal::Init(object String)  = <|
param NetName;
	.NN = instance NNg();
	.NN->Load(NetName);
	.NN.ScaleShift = << << 123.0 >>, << 1.0 / 255.0 >> >>;
|>;
//============================================
//
//============================================
new NNGlobal::BuildMasks(refer object String) = <|
param SrcName;

	new Src = instance FCMathImageSet(<<SrcName>>, 0, 3);
	Src.Average = TRUE;
	Src->SetScaleShift(<< 123.0 >>, << 1.0 / 255.0 >>);
	Src.Binning = 1;
	
	new st = Clock();
	new img = Src->GetImage(0)[0];
	if (img->Width() != 1168 || img->Height() != 320)
	{
		trace Printf("image %d x %d\r\n", img->Width(), img->Height());
		img = instance FCMathImage(instance FMathImage(img, 0, 0, 1168, 320));
	}
	else
		img = Src->GetImage(0);
	.NN->Map(img);
	trace Printf("NN time = %g\r\n", Clock() -  st);

	new sclera = .NN->GetMapImage()[0];
	sclera = instance MathImage(sclera * 255);
	sclera->ToBilevel(230, 1);

	new iris = .NN->GetMapImage()[1];
	iris = instance MathImage(iris * 255);
	iris->ToBilevel(200, 1);

	new irsi_ctr = iris->GetContours();
	for (new i = irsi_ctr->Len() - 1; i >= 0; --i)
	{
		if (irsi_ctr->Len() > 1 && irsi_ctr[i]->Len() < 120)
			irsi_ctr->Remove(i);
		else
		{
			for (new j = irsi_ctr[i]->Len() - 1; j >= 0; --j)
				irsi_ctr[i][j] = instance POINT(irsi_ctr[i][j][0], irsi_ctr[i][j][1]);
			new bs = instance BetaContour(irsi_ctr[i]);
			bs->RebuildEx(irsi_ctr[i]->Len() / 5);
			irsi_ctr[i] <- bs;
		}
	}

	new ctr_sclera = sclera->GetContours();
	for (i = ctr_sclera->Len() - 1; i >= 0; --i)
	{
		if (ctr_sclera->Len() > 1 && ctr_sclera[i]->Len() < 120)
			ctr_sclera->Remove(i);
		else
		{
			for (new j = ctr_sclera[i]->Len() - 1; j >= 0; --j)
				ctr_sclera[i][j] = instance POINT(ctr_sclera[i][j][0], ctr_sclera[i][j][1]);
			new bs = instance BetaContour(ctr_sclera[i]);
			bs->RebuildEx(ctr_sclera[i]->Len() / 10);
			ctr_sclera[i] <- bs;
		}
	}

	sclera->Set(0);
	iris->Set(0);
	
	for (i = irsi_ctr->Len() - 1; i >= 0; --i)
	{
		new iris_mask = sclera->GetSplineMask(irsi_ctr[i]);
		iris |= iris_mask;
		iris_mask *= -2;
		sclera |= iris_mask;
	}
	iris *= -1;
	iris -= 1;
	iris *= -1;

	new dm = iris->BuildDistanceMap();
	for (i = ctr_sclera->Len() - 1; i >= 0; --i)
	{
		new sclera_mask = sclera->GetSplineMask(ctr_sclera[i]);
		new inv = sclera_mask;
		inv->InverseBilevel();
		inv *= -100;
		new ctr_dm = sclera_mask & dm;
		ctr_dm += inv;
		if (ctr_dm->GetMinimum() < 30)
			sclera |= sclera_mask * -1;
	}
	sclera->SetIfEqual(2, 3);
	return sclera;
|>;
//============================================
//
//============================================
new NNGlobal::SaveMaskContour(refer object String, refer object MathImage, boolean) = <|
param SrcName, mask, SaveMask;
	if (SaveMask)
	{
		new MaskName = JustDirName(SrcName) @ JustName(SrcName) @ ".bin";
		new f = instance File(MaskName);
		f->Open("wb");
		f->Write(mask->GetBits(1));
		f->Close();
	}
	new iris = mask;
	new corner = mask;
	corner->SetIfNotEqual(0, 4);
	iris->SetIfNotEqual(0, 2);
	mask->SetIfNotEqual(0, 1);
	new Image = MathImage::LoadImageSet(SrcName);
	new _ContourName = JustDirName(SrcName) @ JustName(SrcName) @ ".nam";
	new ContourName = JustDirName(SrcName) @ JustName(SrcName) @ ".ctr";
	new iris_ctr = iris->GetContours();
	new corner_ctr = corner->GetContours();
	new ctr = mask->GetContours();
	new f = instance File(ContourName);
	f->Open("wb");
	f->Write("CTR01");

	new f1 = instance File(_ContourName);
	f1->Open("wb");

	new len = ctr->Len() + iris_ctr->Len() + corner_ctr->Len();
	new buff = instance String(2);
	buff->Int16ToString(0, len);
	f->Write(buff);
	new buff_len = instance String(4);
	new buff_p = instance String(8);
	for (new i = 0; i < ctr->Len(); ++i)
	{
		len = ctr[i]->Len();
		buff_len->Int32ToString(0, len);
		f->Write(buff_len);
		for (new j = 0; j < len; ++j)
		{
			new x = float(ctr[i][j][0]);
			new y = float(Image[0]->Height() - ctr[i][j][1]);
			buff_p->FloatToString(0, x);
			buff_p->FloatToString(4, y);
			f->Write(buff_p);
		}
		f1->Write("sclera\r\n");
	}
	for (i = 0; i < iris_ctr->Len(); ++i)
	{
		len = iris_ctr[i]->Len();
		buff_len->Int32ToString(0, len);
		f->Write(buff_len);
		for (new j = 0; j < len; ++j)
		{
			new x = float(iris_ctr[i][j][0]);
			new y = float(Image[0]->Height() - iris_ctr[i][j][1]);
			buff_p->FloatToString(0, x);
			buff_p->FloatToString(4, y);
			f->Write(buff_p);
		}
		f1->Write("iris\r\n");
	}
	for (i = 0; i < corner_ctr->Len(); ++i)
	{
		len = corner_ctr[i]->Len();
		buff_len->Int32ToString(0, len);
		f->Write(buff_len);
		for (new j = 0; j < len; ++j)
		{
			new x = float(corner_ctr[i][j][0]);
			new y = float(Image[0]->Height() - corner_ctr[i][j][1]);
			buff_p->FloatToString(0, x);
			buff_p->FloatToString(4, y);
			f->Write(buff_p);
		}
		f1->Write("corner\r\n");
	}
	f->Close();
|>;

//============================================
//
//============================================
new NNGlobal::Calculate(refer object String, refer object MathImage) = <|
param SrcName, mask;
	mask->SetIfNotEqual(0, 1);
	new mask_ = instance MathImage(600, 320);
	new mask_r = mask;
	mask_r->Set(mask_, 600, 0);
	new mask_l = mask;
	mask_l->Set(mask_, 0, 0);
	new area_l = float(mask_l->Integral());
	new area_r = float(mask_r->Integral());
	mask_l *= -1;
	mask_r *= -1;
	new L = instance Vector(3);
	new R = instance Vector(3);
	new Image = MathImage::LoadImageSet(SrcName);
	for (new i = 0; i < Image->Len(); ++i)
	{
		Image[i] = instance MathImage(Image[i], 0, 0, 1168, 320);
		L[i] = Image[i] & mask_l;
		R[i] = Image[i] & mask_r;
	}
	R = Colorimetry(R, 0);
	L = Colorimetry(L, 0);
	trace Printf("area_l = %g, area_r = %g\r\n", area_l, area_r);
	if (L != EMPTY)
	{
		trace Printf("L = %v+-%v\r\n", L[0], Sqrt(L[1]));
	}
	if (R != EMPTY)
	{
		trace Printf("R = %v+-%v\r\n", R[0], Sqrt(R[1]));
	}

	new ResultName = JustDirName(SrcName) @ JustName(SrcName) @ ".res";
	new f = instance File(ResultName);
	if (area_l > 0.0 && area_r > 0.0)
	{
		L[0] += 1.0 / 3.0;
		R[0] += 1.0 / 3.0;
		new res = R[0] / L[0];
		new disp = res ** 2.0 * (L[1] / L[0] ** 2.0 + R[1] / R[0] ** 2.0);
		new txt;
		switch (CurLocale.Code)
		{
		case "ger" :
			txt = Printf("Rechts/Links Rötungsverhältnis = %5.3f+-%5.3f", res, Sqrt(disp));
//			txt = Printf("Rötung links gegen rechts = %5.3f+-%5.3f", res, Sqrt(disp));
			break;
		case "eng" :
			txt = Printf("Right/Left Redness Ratio = %5.3f+-%5.3f", res, Sqrt(disp));
			break;
		}
		trace txt, CR;
		f->Open("wb");
		f->Printf(txt);
		f->Close();
	}
	else
	{
		if (area_l > 0.0)
		{
			new txt = Printf("Left = %5.2f+-%5.3f\r\n", L[0], Sqrt(L[1]));
			trace txt, CR;
			f->Open("wb");
			f->Printf(txt);
			f->Close();
		}
		else
		if (area_r > 0.0)
		{
			new txt = Printf("Right = %5.2f+-%5.3f\r\n", R[0], Sqrt(R[1]));
			trace txt, CR;
			f->Open("wb");
			f->Printf(txt);
			f->Close();
		}
		else
		{
			f->Open("wb");
			switch (CurLocale.Code)
			{
			case "ger" :
				f->Printf("Links/Rechts Rötungsverhältnis = FEHLER");
				break;
			case "eng" :
				f->Printf("Right/Left Red Ratio = FAILURE");
				break;
			}
			f->Close();
		}
	}
|>;
/*
PlukCOMServer::Server->SetNameServer("ANNGlobal");
PlukCOMServer::Server->AddClass("NNGlobal", <<"Init", "FindMasks">>);

PlukCOMServer::Server->SetAutoKill(TRUE);
PlukCOMServer::Server->SetTypeObject(REGCLS_SINGLEUSE);
*/
//new _CmdLine = CmdLine;
new _CmdLine = << "p:\\Yura\\NN\\NN-2020-05-21-g-0.991305-78065.1.nn", "c:\\Allergoscope\\yu ya\\test 2019-12-23 16-19-54\\2019-12-23 16-20-02.jpg" >>;
trace _CmdLine, CR; 	
global nn = instance NNGlobal();

if (_CmdLine->Len() > 0)
{
	onerror {
		end;
	}
	new MaskName = JustDirName(_CmdLine[1]) @ JustName(_CmdLine[1]) @ ".bin";
	new f = instance File(MaskName);
	if (_CmdLine->Len() >= 3 && _CmdLine[2] == "/recalc" && f->Access(ACCESS_EXIST) == TRUE)
	{
		f->Open("rb");
		new bits = f->Read(-1);
		f->Close();
		new mask = instance MathImage(1, bits, 0, 1200, 316);
		nn->SaveMaskContour(_CmdLine[1], mask, FALSE);
		nn->Calculate(_CmdLine[1], mask);
	}
	else
	{
		nn->Init(_CmdLine[0]);
		new mask = nn->BuildMasks(_CmdLine[1]);
		nn->SaveMaskContour(_CmdLine[1], mask, TRUE);
		nn->Calculate(_CmdLine[1], mask);
	}
	end;
}
